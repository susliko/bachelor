\documentclass[14pt, openany]{book}
\pagestyle{plain}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{extsizes}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{tempora}
\usepackage{amsmath}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}
\usepackage{natbib}
\usepackage{indentfirst}
\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    frame=single,
    aboveskip=5mm,
    belowskip=5mm,
    backgroundcolor=\color{backcolour},   
    language=scala,
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\small\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=7pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
  
\geometry{
    a4paper,
    left=20mm,
    top=20mm,
    right=20mm,
    bottom=20mm
}
\linespread{1.5}

\title{Тестирование конкурентных структур данных на соответствие моделям согласованности}
\author{Морковкин Василий}
\date{2020}
\setlength{\parindent}{2em}

\begin{document}
\maketitle
\chapter*{Аннотация}
\par
Чтение данных с записывающего устройства, проведение сетевых запросов и одновременная обработка поступающих команд - одни из задач, стоящих перед программным обеспечением. Результатом оптимизации затрат процессорного времени на решение этих задач стало появление ряда техник  \textit{конкурентного программирования}. Однако необходимость использования ресурсов, не поддерживающих одновременный доступ, зависимость от системного планировщика задач, а также особенности устройства процессорных кешей могут приводить к неопределенным или нежелаемым исполнениям компьютерных программ. Целью конкурентного программирования является предоставление механизмов и методик, которые бы позволили писать корректный, обладающий определенным поведением код. Одним из важнейших механизмов являются \textit{структуры данных}, пригодные для использования в конкурентной среде. Для описания их свойств и предоставляемых гарантий был разработан ряд \textit{моделей согласованности}. \par
Проверка алгоритмов на соответствие этим моделям может быть осуществлена с помощью методов формальной верификации. Однако для проверки конкретных их реализаций на языках программирования доступно лишь тестирование с перебором некоторого подмножества всех сценариев исполнения. В этой работе будут рассмотрены существующие модели согласованности конкурентных структур данных, разработаны варианты их тестирования, и, наконец, реализованы в виде библиотеки на языке программирования Scala.
\setcounter{page}{1}
\tableofcontents
\clearpage



\chapter{Введение}

\section{Основные понятия}
Введем основные понятия, необходимые в дальнейшем.

\emph{Операция} --- действие, состоящее из некоторого числа программных инструкций. Под этим словом будут подразумеваться отдельные взаимодействия со структурой данных (вставка, удаление, поиск и т.д.).

\emph{Процесс} --- последовательность операций, исполняемая любой единицей исполнения (системным процессом, системной нитью, нитью виртуальной машины, легковесной нитью и т.д.)

\emph{Структура данных} --- формат хранения и управления данным, предоставляющий интерфейс для доступа к ним и их изменения.

\emph{Конкурентные операции} --- две или более операций, временные интервалы исполнения которых пересекаются.

\emph{Конкурентные процессы} --- процессы, исполняющие конкурентные операции.

\emph{Конкурентная структура данных} --- структура данных, подчиняющаяся законам некоторой модели согласованности. Иными словами, структура данных, пригодная для использования конкурентными процессами. 

\emph{Модель согласованности} --- набор гарантий о предсказуемости результатов чтения, записи и изменения данных, позволяющий рассуждать о поведении компьютерной программы.

\section{Цели работы}

\begin{itemize}
  \item Изучить проблемы, возникающие при конкурентном программировании,
  \item исследовать наиболее распространенные модели согласованности,
  \item разработать алгоритмы тестирования моделей согласованности,
  \item реализовать библиотеку для тестирования конкретных реализаций структур данных на выполнение выбранных моделей согласованности.
\end{itemize}

\section{План работы}
В \textit{Главе 2} будут рассмотрены основные проблемы, а также причины их возникновения, с которыми сталкиваются разработчики при конкурентном программировании, такие как \textit{состояние гонки}, \textit{гонка на данных} и \textit{взаимная блокировка}. Затем будут выделены модели согласованности конкурентных структур данных, такие как \textit{последовательная согласованность}, \textit{линеаризуемость} и различные ослабленные варианты линеаризуемости.\par
В \textit{Главе 3} будет представлен анализ задачи тестирования конкурентных структур данных, а также предложен ряд конкретных алгоритмов тестирования. Также в главе пойдет рассуждение о хорошем дизайне для библиотеки с описанным функционалом тестирования. \par
\textit{Глава 4} включит в себя заметки о реализации библиотеки на языке программирования \textit{Scala}. Выбор языка обусловлен его встроенными метапрограммированием, возможностью написания на нем удобных предметно-ориентированных языков, возможностью использования мощной стандартной библиотеки \linebreak \textit{java.util.concurrent}, а также практической нуждой в подобной библиотеке. Все примеры кода в работе также будут приведены на языке \textit{Scala} версии \textit{2.13}.

\chapter{Конкурентное программирование}

\section{Проблемы}
В данном разделе мы рассмотрим ряд проблем, возникающих при помещении программ в конкурентную среду.
Первая из них --- гонка на данных.

\subsection{Гонка на данных}
\textit{Гонкой на данных} называют \cite{dataRace} обращения к одному и тому же участку памяти, совершаемые из конкурентных процессов при условии, что хотя бы одно из обращений является обращением на запись, и обращения происходят не в рамках операций синхронизации. Под операциями синхронизации подразумевают, например, вызовы методов мониторов и барьеров памяти.
\par Рассмотрим пример, содержащий гонку на данных:

\lstinputlisting[language=Scala, 
caption=Пример гонки на данных
]{DataRace.scala}

Результатом исполнения приведенного кода может стать зависание программы в бесконечном цикле. Причиной этого является копирование значений переменных, с которыми работает процесс, в кеш вычислительного процессора, и последующего чтения из него в то время, когда значение переменной уже было изменено. Данное копирование происходит с целью увеличения эффективности, так как доступ к процессорному кешу значительно быстрее \cite{timings} доступа к оперативной памяти. \par
Описанная проблема решается путем синхронизации обращений к переменных через примитивы синхронизации, встроенные в язык программирования (например, мониторов в Java). Для обнаружения гонок на данных были разработаны специальные инструменты \cite{threadSanitizer, javaThreadSanitizer}.

\subsection{Состояние гонки}
Другая проблема --- \textit{состояние гонки}. Несмотря на похожие названия, описанная ранее проблема не имеет прямого отношения к текущей. Гонка на данных возможна без состояния гонки и наоборот \cite{dataRaceVsCondition}  \par
\textit{Состоянием гонки} называют \cite{raceCondition} ситуацию, в которой несколько процессов производят чтение и запись в разделяемую память, и при этом результат их операций зависит от порядка исполнения.\par
Рассмотрим пример кода, содержащий состояние гонки:
\lstinputlisting[language=Scala,
caption=Пример состояния гонки]{RaceCondition.scala}
Результат исполнения приведенного кода двумя процессами зависит от относительного порядка исполнения отдельных операций в этих процессах:
\vspace{-0.8em}
\begin{table}[!htb]
    \begin{minipage}{.5\linewidth}
      \caption{Исполнение 1}
      \centering
        \begin{tabular}{|c|c|}
        \hline
        Процесс 1& Процесс 2\\
        \hline
        from.get: 100 & \\
        to.get: 100  & \\
        from.set: 90 & \\
         & from.get: 90 \\
         & to.get: 100 \\
         & from.set: 80 \\
        to.set: 110 & \\
         & to.set: 110 \\
        \hline
        \multicolumn{2}{| c |}{Итог: from = 80, to = 110}\\
        \hline
        \end{tabular}
    \end{minipage}%
    \begin{minipage}{.5\linewidth}
      \caption{Исполнение 2}
      \centering
        \begin{tabular}{|c|c|}
        \hline
        Процесс 1& Процесс 2\\
        \hline
        from.get: 100 & \\
        to.get: 100  & \\
         & from.get: 100 \\
         & to.get: 100 \\
         & from.set: 90 \\
        from.set: 90  & \\
        to.set: 110 & \\
         & to.set: 120 \\
        \hline
        \multicolumn{2}{| c |}{Итог: from = 90, to = 120}\\
        \hline
        \end{tabular}
    \end{minipage}
\end{table}

Видно, что в первом исполнении суммарное число денег на банковских счетах \textbf{from} и \textbf{to} уменьшилось, а во втором увеличилось, в то время как при исполнении на одном процессе оно не меняется. Данный пример показывает, что состояние гонки может появляться и в хорошо синхронизированном коде, в котором отсутствуют гонки на данных. Для рассуждения о программах, которые не подвержены таким проблемам, нам понадобится ввести понятия моделей согласованности, о которых речь пойдет далее.

\subsection{Взаимная блокировка}
Ещё одной частой причиной некорректного поведения конкурентных программ является состояние \textit{взаимной блокировки}, при котором каждый процесс находится в ожидании совершения какого-то действия (отправки сообщения, отпускания блокировки) другим процессом. Система, находящаяся в таком состоянии, не делает прогресса. \par
Взаимная блокировка определяется одновременным выполнением следующих условий \cite{deadlock}:
\begin{itemize}
    \item Процессы требуют эксклюзивного владения ресурсами.
    \item Процессы, владеющие ресурсами, также ждут возможности завладеть некоторыми дополнительными ресурсами.
    \item Блокировка ресурса может быть отпущена только тем процессом, который им владеет в данный момент.
    \item В системе существует замкнутая цепь процессов, таких, что каждый процесс из цепи владеет одним или несколькими ресурсами, которые также необходимы следующему процессу в цепи.
\end{itemize}
Для наглядности рассмотрим пример:
\lstinputlisting[language=Scala,
caption=Пример взаимной блокировки]{Deadlock.scala}

В зависимости от системного планировщика приведенная программа может как завершаться, так и повисать навечно в случае возникновения состояния взаимной блокировки, когда процесс первого блока \textit{Future} не успевает захватить блокировку на объект \textit{lock2} прежде процесса второго блока \textit{Future}.
\section{Модели согласованности}
Все рассмотренные нами проблемы обладают общим свойством -- они проявляются не всегда, а только при стечении определенных обстоятельств, не подконтрольных программисту, таких как состояние процессорных кешей и результат работы системного планировщика. Такое непостоянство, а также большое мест в коде, которые могут вызывать проблемы, делает сложным воспроизведение и исправление ошибок. \par
Поэтому была разработан формализм \textit{моделей согласованности}, который вводит свойства корректности всех конкурентных исполнений некоторого кода, а также дает возможность рассуждать о композиции этих свойств при объединении корректных по отдельности участков кода. \par
В этом разделе мы рассмотрим несколько широко применяемых моделей согласованности, таких как \textit{последовательная согласованность} и \textit{линеаризумость}.
\subsection{Последовательная согласованность}
Говорят \cite{sequential}, что некоторый участок кода является \textit{последовательно согласованным}, если результат любого его конкурентного исполнения такой же, как если бы все операции всех процессов исполнялись в некотором последовательном порядке, в котором сохранялся бы относительный порядок операций каждого отдельного процесса. Это свойство также не допускает возникновения состояний взаимной блокировки \par
Рассмотрим это понятие на примере. Пусть есть структура данных, которая поддерживает семантику ``первым пришел -- первым ушел''  при исполнениях на одном процессе. Пусть она имеет следующий интерфейс:
\lstinputlisting[language=Scala, caption=Интерфейс очереди]{Queue.scala}
Если ее реализация утверждает, что она последовательно согласованна, то она не должна допускать подобных исполнений: 

\begin{figure}[h]
\caption{Последовательно не согласованное исполнение}
\vspace{2mm}
\centering
\includegraphics[scale=0.4]{NonSequential.jpg}
\end{figure}
В данном случае нарушается требование существования исполнения на одном процессе, в котором операция \textit{dequeue} вернула бы единицу дважды. \par
Однако подобные исполнения: 

\begin{figure}[h]
\caption{Последовательно согласованное исполнение}
\label{fig:sequential}
\vspace{2mm}
\centering
\includegraphics[scale=0.4]{Sequential.jpg}
\end{figure}
\noindentдопускаются, так как в данном случае все операции можно упорядочить в линейную историю, которая подчиняется спецификации объекта и сохраняет относительный порядок операций каждого из процессов:
\begin{figure}[h]
\caption{Объясняющее последовательное исполнение}
\label{fig:sequentialExpl}
\vspace{2mm}
\centering
\includegraphics[scale=0.4]{SequentialExpl.jpg}
\end{figure}

Корректность конкурентного исполнения, приведенного на рисунке \ref{fig:sequential}, может показаться контр-интуитивной, поскольку операция \textit{dequeue -> 2} завершилась раньше во времени, чем \textit{dequeue -> 1} в отличие от объясняющего последовательного исполнения на рисунке \ref{fig:sequentialExpl}. \par
Также стоит отметить, что результат композиции последовательно согласованных объектов может не являться последовательно согласованным. Рассмотрим некоторую конкурентную историю для двух очередей \textit{Q1} и \textit{Q2}:

\begin{figure}[h]
\caption{Композиция последовательно согласованных объектов}
\vspace{2mm}
\centering
\includegraphics[scale=0.4]{SequentialComp.jpg}
\end{figure}
\noindent Для каждой из очередей по отдельности можно составить объясняющие последовательные истории, однако для всего исполнения в данном случае этого сделать нельзя. \par
Более строгой моделью согласованности, которая учитывает временной порядок операций, а также обладает свойством композиции, является \textit{линеаризуемость}. 
\subsection{Линеаризуемость}

\subsection{Ослабленная линеаризуемость}

\chapter{Тестирование моделей согласованности}

\section{Алгоритмическая сложность тестирования}

\section{Алгоритмы тестирования}

\subsection{Последовательная согласованность}

\subsection{Линеаризуемость}

\subsection{Ослабленная линеаризуемость}

\section{Разработка требований к библиотеке}

\subsection{Интерфейс}

\subsection{Конфигурация}

\chapter{Реализация библиотеки}

\section{Интерфейс}

\section{Генерация тестовых сценариев}

\section{Запуск тестовых сценариев}

\section{Валидация результатов исполнения}

\section{Генерация отчета тестирования}

\chapter{Выводы}

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}

