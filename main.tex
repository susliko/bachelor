\documentclass[14pt, openany]{book}
\pagestyle{plain}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{extsizes}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{tempora}
\usepackage{amsmath}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}
\usepackage{natbib}
\usepackage{indentfirst}
\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    frame=single,
    aboveskip=5mm,
    belowskip=5mm,
    backgroundcolor=\color{backcolour},   
    language=scala,
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\small\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=7pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
  
\geometry{
    a4paper,
    left=20mm,
    top=20mm,
    right=20mm,
    bottom=20mm
}
\linespread{1.5}

\title{Тестирование конкурентных структур данных на соответствие моделям согласованности}
\author{Морковкин Василий}
\date{2020}
\setlength{\parindent}{2em}

\begin{document}
\maketitle
\chapter*{Мотивация}
\par
Чтение данных с записывающего устройства, проведение сетевых запросов и одновременная обработка поступающих команд - одни из задач, стоящих перед программным обеспечением. Результатом оптимизации затрат процессорного времени на решение этих задач стало появление ряда техник  \textit{конкурентного программирования}. Однако необходимость использования ресурсов, не поддерживающих одновременный доступ, зависимость от системного планировщика задач, а также особенности устройства процессорных кешей могут приводить к неопределенным или нежелаемым исполнениям компьютерных программ. Целью конкурентного программирования является предоставление механизмов и методик, которые бы позволили писать корректный, обладающий определенным поведением код. Одним из важнейших механизмов являются \textit{структуры данных}, пригодные для использования в конкурентной среде. Для описания их свойств и предоставляемых гарантий был разработан ряд \textit{моделей согласованности}. \par
Проверка алгоритмов на соответствие этим моделям может быть осуществлена с помощью методов формальной верификации. Однако для проверки конкретных их реализаций на языках программирования доступно лишь тестирование с перебором некоторого подмножества всех сценариев исполнения. В этой работе будут рассмотрены существующие модели согласованности конкурентных структур данных, разработаны варианты их тестирования, и, наконец, реализованы в виде библиотеки на языке программирования Scala.
\setcounter{page}{1}
\tableofcontents
\clearpage



\chapter{Введение}

\section{Основные понятия}
Введем основные понятия, необходимые в дальнейшем.

\emph{Операция} --- действие, состоящее из некоторого числа программных инструкций. Под этим словом будут подразумеваться отдельные взаимодействия со структурой данных (вставка, удаление, поиск и т.д.).

\emph{Процесс} --- последовательность операций, исполняемая любой единицей исполнения (системным процессом, системной нитью, нитью виртуальной машины, легковесной нитью и т.д.)

\emph{Структура данных} --- формат хранения и управления данным, предоставляющий интерфейс для доступа к ним и их изменения.

\emph{Конкурентные операции} --- две или более операций, временные интервалы исполнения которых пересекаются.

\emph{Конкурентные процессы} --- процессы, исполняющие конкурентные операции.

\emph{Конкурентная структура данных} --- структура данных, подчиняющаяся законам некоторой модели согласованности. Иными словами, структура данных, пригодная для использования конкурентными процессами. 

\emph{Модель согласованности} --- набор гарантий о предсказуемости результатов чтения, записи и изменения данных, позволяющий рассуждать о поведении компьютерной программы.

\section{Цели работы}

\begin{itemize}
  \item Изучить проблемы, возникающие при конкурентном программировании,
  \item исследовать наиболее распространенные модели согласованности,
  \item разработать алгоритмы тестирования моделей согласованности,
  \item реализовать библиотеку для тестирования конкретных реализаций структур данных на выполнение выбранных моделей согласованности.
\end{itemize}

\section{План работы}
В \textit{Главе 2} будут рассмотрены основные проблемы, а также причины их возникновения, с которыми сталкиваются разработчики при конкурентном программировании, такие как \textit{состояние гонки}, \textit{гонка на данных} и \textit{взаимная блокировка}. Затем будут выделены модели согласованности конкурентных структур данных, такие как \textit{последовательная согласованность}, \textit{линеаризуемость} и различные ослабленные варианты линеаризуемости.\par
В \textit{Главе 3} будет представлен анализ задачи тестирования конкурентных структур данных, а также предложен ряд конкретных алгоритмов тестирования. Также в главе пойдет рассуждение о хорошем дизайне для библиотеки с описанным функционалом тестирования. \par
\textit{Глава 4} включит в себя заметки о реализации библиотеки на языке программирования \textit{Scala}. Выбор языка обусловлен его встроенными метапрограммированием, возможностью написания на нем удобных предметно-ориентированных языков, возможностью использования мощной стандартной библиотеки \linebreak \textit{java.util.concurrent}, а также практической нуждой в подобной библиотеке. Все примеры кода в работе также будут приведены на языке \textit{Scala}.

\chapter{Конкурентное программирование}

\section{Проблемы}
В данной секции мы рассмотрим ряд проблем, возникающих при помещении программ в конкурентную среду.
Первая из них --- гонка на данных.

\subsection{Гонка на данных}
\textit{Гонкой на данных} называют \cite{dataRace} обращения к одному и тому же участку памяти, совершаемые из конкурентных процессов при условии, что хотя бы одно из обращений является обращением на запись, и обращения происходят не в рамках операций синхронизации. Под операциями синхронизации подразумевают, например, вызовы методов мониторов и барьеров памяти.
\par Рассмотрим пример, содержащий гонку на данных:

\lstinputlisting[language=Scala, 
caption=Пример гонки на данных
]{DataRace.scala}

Результатом исполнения приведенного кода может стать зависание программы в бесконечном цикле. Причиной этого является копирование значений переменных, с которыми работает процесс, в кеш вычислительного процессора, и последующего чтения из него в то время, когда значение переменной уже было изменено. Данное копирование происходит с целью увеличения эффективности, так как доступ к процессорному кешу значительно быстрее \cite{timings} доступа к оперативной памяти. \par
Описанная проблема решается путем синхронизации обращений к переменных через примитивы синхронизации, встроенные в язык программирования (например, мониторов в Java). Для обнаружения гонок на данных были разработаны специальные инструменты \cite{threadSanitizer, javaThreadSanitizer}.

\subsection{Состояние гонки}
Другая проблема --- \textit{состояние гонки}. Несмотря на похожие названия, описанная ранее проблема не имеет прямого отношения к текущей. Гонка на данных возможна без состояния гонки и наоборот \cite{dataRaceVsCondition}  \par
\textit{Состоянием гонки} называют \cite{raceCondition} называют ситуацию, в которой несколько процессов производят чтение и запись в разделяемую память, и при этом результат их операций зависит от порядка исполнения.\par
Рассмотрим пример кода, содержащий состояние гонки:
\lstinputlisting[language=Scala,
caption=Пример состояния гонки]{RaceCondition.scala}

\subsection{Взаимная блокировка}

\section{Модели согласованности}

\subsection{Последовательная согласованность}

\subsection{Линеаризуемость}

\subsection{Ослабленная линеаризуемость}

\chapter{Тестирование моделей согласованности}

\section{Алгоритмическая сложность тестирования}

\section{Алгоритмы тестирования}

\subsection{Последовательная согласованность}

\subsection{Линеаризуемость}

\subsection{Ослабленная линеаризуемость}

\section{Разработка требований к библиотеке}

\subsection{Интерфейс}

\subsection{Конфигурация}

\chapter{Реализация библиотеки}

\section{Интерфейс}

\section{Генерация тестовых сценариев}

\section{Запуск тестовых сценариев}

\section{Валидация результатов исполнения}

\section{Генерация отчета тестирования}

\chapter{Выводы}

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}

